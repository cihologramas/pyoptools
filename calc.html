<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>calc module &#8212; pyOpTools .1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="pyOpTools .1 documentation" href="modules.html" />
    <link rel="prev" title="calc" href="modules.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-calc">
<span id="calc-module"></span><h1>calc module<a class="headerlink" href="#module-calc" title="Permalink to this headline">¶</a></h1>
<p>Method collection to obtain optical system information</p>
<p>This module contains a method collection to obtain information, and analyze
optical systems</p>
<dl class="function">
<dt id="calc.aux_paral_f">
<code class="descclassname">calc.</code><code class="descname">aux_paral_f</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#aux_paral_f"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.aux_paral_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary function needed in parallel propagate</p>
</dd></dl>

<dl class="function">
<dt id="calc.aux_paral_f_ns">
<code class="descclassname">calc.</code><code class="descname">aux_paral_f_ns</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#aux_paral_f_ns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.aux_paral_f_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary function needed in parallel propagate</p>
</dd></dl>

<dl class="function">
<dt id="calc.chief_ray_search">
<code class="descclassname">calc.</code><code class="descname">chief_ray_search</code><span class="sig-paren">(</span><em>opsys</em>, <em>ccds</em>, <em>o=(0.0</em>, <em>0.0</em>, <em>0.0)</em>, <em>rt=(0.0</em>, <em>0.0</em>, <em>0.0)</em>, <em>er=0.1</em>, <em>w=1.5707963267948966</em>, <em>maxiter=1000</em>, <em>wavelength=0.58929</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#chief_ray_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.chief_ray_search" title="Permalink to this definition">¶</a></dt>
<dd><p>This function uses a random search algorithm to find the chief_ray for a
given optical system and object point.</p>
<p><strong>Algorithm description:</strong></p>
<p>The algorithm starts using a given ray, propagating it in the optical
system, and finding the intersection point of this test ray and the
aperture plane. The distance from this point and the optical axis is
recorded.</p>
<p>Using a gaussian random generator, two rotation angles are calculated,
to generate a new test ray that is propagated in the optical system,
and its distance to the optical axis is found at the aperture plane.
If this distance is less than the distance found for the previous ray,
this ray is taken as the new <em>chief ray</em> candidate, and  the algorithm
is repeated until the number of iterations reaches <em>maxiter</em>, or until
the distance is less than <em>er</em>.</p>
<p>the <em>rt</em> parameter gives the rotations made to a ray originating in
<em>o</em>, and propagating in the <em>Z</em> direction, to find the first test ray.</p>
<p>A detector object <em>ccds</em> should be placed at the aperture plane. It is used
to find the point where the ray intersects the aperture. To increase the
convergense speed of the algorithm, it is better to make sure that the first
test ray intersects the detector.</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>opsys</td>
<td>Optical system that will be used to find the chief ray</td>
</tr>
<tr class="row-even"><td>ccds</td>
<td>Detector placed in the aperture plane. Should be
centred in the optical axis</td>
</tr>
<tr class="row-odd"><td>o</td>
<td>Tuple, list or numpy array indicating the coordinates
of the object point used to find the chief ray</td>
</tr>
<tr class="row-even"><td>rt</td>
<td>Tuple with the rotations made to a ray propagating in
the z direction to obtain the first test ray</td>
</tr>
<tr class="row-odd"><td>er</td>
<td>Maximum acceptable distance between the ray and the
center of the aperture</td>
</tr>
<tr class="row-even"><td>w</td>
<td>Gaussian width in radians</td>
</tr>
<tr class="row-odd"><td>wavelength</td>
<td>Wavelength of the ray used to find the principal ray given
in micrometers (.58929 by default).</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><strong>Return Value:</strong></p>
<blockquote>
<div>Chief ray found. (Ray instance)</div></blockquote>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Implement a function similar to this one, using a minimization
algorithm</p>
</div>
</dd></dl>

<dl class="function">
<dt id="calc.find_apperture">
<code class="descclassname">calc.</code><code class="descname">find_apperture</code><span class="sig-paren">(</span><em>ccd</em>, <em>size=(50</em>, <em>50)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#find_apperture"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.find_apperture" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to find a mask representing the aperture</p>
<p>This function returns a array containing 1&#8217;s and 0&#8217;s representing
the aperture shape. The aperture shape will be approximated from
the CCD hit_list</p>
<p>Attributes:</p>
<dl class="docutils">
<dt><em>ccd</em></dt>
<dd>CCD object that will be used to get the shape information</dd>
<dt><em>size</em></dt>
<dd>Array shape</dd>
</dl>
<p>Note: Right now only works for round appertures.</p>
</dd></dl>

<dl class="function">
<dt id="calc.find_ppp">
<code class="descclassname">calc.</code><code class="descname">find_ppp</code><span class="sig-paren">(</span><em>opsys</em>, <em>opaxis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#find_ppp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.find_ppp" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to find the primary principal plane location of a lens or an
optical component</p>
<p>Arguments:</p>
<dl class="docutils">
<dt>opsys</dt>
<dd>Optical system or optical component whose principal planes are to be
found</dd>
<dt>opaxis</dt>
<dd>Ray defining the optical axis of the system</dd>
</dl>
<p>For this function to operate, the system should have a rotational symmetry
around the optical axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is returns the intersection point of the optical axis and
the principal plane.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="calc.find_reference_sphere_radius">
<code class="descclassname">calc.</code><code class="descname">find_reference_sphere_radius</code><span class="sig-paren">(</span><em>ip</em>, <em>pl</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#find_reference_sphere_radius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.find_reference_sphere_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the radius os the reference sphere that best fits the input data.</p>
<p>This method asumes that the optical axis coincides with the z axis. This
means that the center of the sphere, has coordinates (0,0,r).</p>
<p>Attributes:</p>
<dl class="docutils">
<dt>ip</dt>
<dd>list of the points where the optical path is measured, that are being
fitted. Each point is (XYZ) tuple. It can be also an array with a shape
n,3 where n is the numbre of points.</dd>
<dt>pl</dt>
<dd>List of path lengths. pl[i] corresponds to the point ip[i].</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calc.get_optical_path_ep">
<code class="descclassname">calc.</code><code class="descname">get_optical_path_ep</code><span class="sig-paren">(</span><em>opsys</em>, <em>opaxis</em>, <em>raylist</em>, <em>stop=None</em>, <em>r=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#get_optical_path_ep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.get_optical_path_ep" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the optical path traveled by a ray up to the exit pupil</p>
<p>The optical path is measured from the ray origin until it crosses the
exit pupil of the system.
If a stop (aperture) is not given, the measurement is made up to the primary
principal plane.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt>opsys</dt>
<dd>Optical system under analisis</dd>
<dt>opaxis</dt>
<dd>Ray indicating the optical axis the origin of the optical axis, must be
the position of the object used in the image formation. This is needed
to be able to calculate the radius of the reference sphere.</dd>
<dt>raylist</dt>
<dd>List of rays that will be used to sample the optical path</dd>
<dt>stop</dt>
<dd>Aperture stop of the system. It must belong to opsys. In not given it
will be assumed that the exit pupil is at the primary principal plane.</dd>
<dt>r</dt>
<dd>If None, measure up to the exit pupil plane. If given, use a reference
sphere with a vertex coinciding with the optical vertex.</dd>
</dl>
<p>Return Value (hcl,opl,pc)</p>
<dl class="docutils">
<dt>hcl</dt>
<dd>List containing the coordinates of the hits in the pupil coordinate
system.</dd>
<dt>opl</dt>
<dd>list containing the optical paths measured</dd>
<dt>pc</dt>
<dd>intersection point between the optical axis, and the pupil plane.</dd>
</dl>
<p>hcl[i] corresponds to opl[i]</p>
<p>Note: This method only works if the optical axis coincides with the Z axis.
This must be corrected.</p>
</dd></dl>

<dl class="function">
<dt id="calc.intersection">
<code class="descclassname">calc.</code><code class="descname">intersection</code><span class="sig-paren">(</span><em>r1</em>, <em>r2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the point of intersection between the rays r1 and r2.</p>
<p><strong>Arguments:</strong></p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r1</td>
<td>First Ray to test for intersection</td>
</tr>
<tr class="row-even"><td>r2</td>
<td>Second Ray to test for intersection</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><strong>Return Value:</strong></p>
<blockquote>
<div><p>Tuple (ip,rv) where:</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ip</td>
<td>Intersection point coordinates. If the rays do not intersect
ip=(nan,nan,nan)</td>
</tr>
<tr class="row-even"><td>rv</td>
<td>Boolean that indicates if the intersection point represent a
real image (rv=true) , or a virtual image (rv=false).</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="calc.nearest_points">
<code class="descclassname">calc.</code><code class="descname">nearest_points</code><span class="sig-paren">(</span><em>ray1</em>, <em>ray2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#nearest_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.nearest_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nearest points between 2 rays.</p>
<p>The image point locations in optical systems are usually found by
calculating the intersection between rays coming from a single object
point, but in aberrated systems, the 2 rays will not really intersect.
This function is used to find the point in space where the rays
are closest to each other. If the rays intersect the values returned
will be the intersection point.</p>
<p>The solution was taken from:</p>
<blockquote>
<div><a class="reference external" href="http://homepage.univie.ac.at/Franz.Vesely/notes/hard_sticks/hst/hst.html">http://homepage.univie.ac.at/Franz.Vesely/notes/hard_sticks/hst/hst.html</a></div></blockquote>
<p><strong>Arguments:</strong></p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r1</td>
<td>First Ray to test for intersection</td>
</tr>
<tr class="row-even"><td>r2</td>
<td>Second Ray to test for intersection</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><strong>Return Value</strong></p>
<blockquote>
<div><p>The return value is a tuple (p1,p2,d,rv) where:</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>p1</td>
<td>The point liying on the ray 1, closest to the ray 2</td>
</tr>
<tr class="row-even"><td>p2</td>
<td>The point liying on the ray 2, closest to the ray 1</td>
</tr>
<tr class="row-odd"><td>d</td>
<td>The distance between p1 and p2</td>
</tr>
<tr class="row-even"><td>rv</td>
<td>a boolean indicating if the intersection is real or virtual
rv=True for real, rv=False for virtual</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="calc.parallel_propagate">
<code class="descclassname">calc.</code><code class="descname">parallel_propagate</code><span class="sig-paren">(</span><em>os</em>, <em>r</em>, <em>np=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#parallel_propagate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.parallel_propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a propagation of the rays in the system using all cores
present on a computer</p>
<p>os gets reset before beginning the propagation, so the only rays
used in the simulation are the rays given in r</p>
<p>Parameters</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>os</td>
<td>Optical system used in the simulation</td>
</tr>
<tr class="row-even"><td>r</td>
<td>List containing the rays to propagate</td>
</tr>
<tr class="row-odd"><td>np</td>
<td>Number if processes used in the simulation. If not given use
one process per cpu</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="calc.parallel_propagate_ns">
<code class="descclassname">calc.</code><code class="descname">parallel_propagate_ns</code><span class="sig-paren">(</span><em>os</em>, <em>rg</em>, <em>dp</em>, <em>r</em>, <em>np=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#parallel_propagate_ns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.parallel_propagate_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a propagation of the rays in the system using all cores
present on a computer</p>
<p>os gets reset before beginning the propagation, so the only rays
used in the simulation are the rays given in r</p>
<p>Parameters</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>os</td>
<td>Optical system used in the simulation</td>
</tr>
<tr class="row-even"><td>rg</td>
<td>Guide ray</td>
</tr>
<tr class="row-odd"><td>dp</td>
<td>Destination path</td>
</tr>
<tr class="row-even"><td>r</td>
<td>List containing the rays to propagate</td>
</tr>
<tr class="row-odd"><td>np</td>
<td>Number if processes used in the simulation. If not given use
one process per cpu</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="calc.paraxial_location">
<code class="descclassname">calc.</code><code class="descname">paraxial_location</code><span class="sig-paren">(</span><em>opsys</em>, <em>opaxis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#paraxial_location"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.paraxial_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to find the paraxial image location</p>
<p>This function finds the paraxial image location of a point
located in the optical axis, and a boolean indicating if the image
is real or virtual (image_location, real_virtual).
The origin of the opaxis location is taken as the object location</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><em>opsys</em></dt>
<dd>Optical system to use.</dd>
<dt><em>opaxis</em></dt>
<dd>Ray representating the optical axis</dd>
</dl>
<p>For this function to operate, the system should have a rotational symmetry
around the optical axis.</p>
</dd></dl>

<dl class="function">
<dt id="calc.pupil_location">
<code class="descclassname">calc.</code><code class="descname">pupil_location</code><span class="sig-paren">(</span><em>opsys</em>, <em>ccds</em>, <em>opaxis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#pupil_location"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.pupil_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to find the optical system pupils position</p>
<p><strong>Parameters:</strong></p>
<blockquote>
<div>opsys   Optical system to use.
opaxis  Ray representing the optical axis
ccds    Surface that represents a detector in the aperture plane</div></blockquote>
<p><strong>Return Value</strong></p>
<blockquote>
<div><p>(enpl,expl)</p>
<p>enpl tuple (xen,yen,zen) containing the entrance pupil coordinates
expl tuple (xex,yex,zex) containing the exit pupil coordinates</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="calc.ray_paths">
<code class="descclassname">calc.</code><code class="descname">ray_paths</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/calc.html#ray_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#calc.ray_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lists with all the possible paths traveled by the ray r.</p>
<p>r must be previously propagated in an optical system</p>
<p>When there are beam splitters, there is more than one path</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="modules.html">Documentation overview</a><ul>
      <li>Previous: <a href="modules.html" title="previous chapter">calc</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/calc.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, William Patino.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/calc.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>